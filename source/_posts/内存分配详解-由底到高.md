---
title: 内存分配详解-由底到高
date: 2019-02-26 19:04:53
categories:
- 技术
tags:
- 计算机原理
- C
- iOS
- Python
- Node.js
keywords: 计算机原理,内存分配,内存分区,比特,字节,指针,指针的指针,32位,64位,内存条,4G,8G
---

### 一行代码引发的思考
> int a = 5;

问1:变量a在内存的哪里？
问2:数字5在内存的哪里？
问3:int的字节大小是多少？如果a=12345后，字节大小变不变？
问4:代码里面print("%d", a)，为什么可以输出5，a是怎么找到5的？
问5:内存到底在哪里？
问6:总内存有多大？
问7:总内存的大小是怎么确定的？

各位能回答上面的7问吗？

由底往上来解析，一步一步揭开洋葱的外衣，真相终究会大白于天下！

<!-- more -->

### 字节与比特

比特这玩意，说好理解，马上能理解。说难理解，那肯定还是需要一翻思考总结的。
`比特是计算机存储的最小存储单元`。我们认知到的数字`3`，在计算机的存储里（硬盘或者内存）的结构是这样的：`00000011`。是的，也就是我们理解的二进制。
所以这个数字`3`是由8位组成的。每位有`0`和`1`两种变化。
恐怖的是，比特存储，是计算机的基石。我们在互联网上通行的一切，如图片、音视频、文字，甚至各位的博客、App、电子书等等，能想到的能通过互联网传输的一切，都是比特存储。
举个例子，我们看的一张图片，在磁盘上的存储，或许就是这样子：`0101011101010101010111101011110101010101100***(省略100000000个)***1010100111010101`。
所以，祝各位每年的`1024节`快乐，因为我们的努力，世界才如此缤纷多彩 ：)

1字节(byte)=8比特(bit)
我们刚才说到的数字`3`，就是一个字节，在磁盘上就是`00000011`。（为了便于理解，实际可能是`00000000 00000011`，或者`00000000 00000000 00000000 00000011`）。
`1字节=8比特`，这个是定死的，开始就是这么玩的，也会永远的玩下去。

1KB = 1024B（2的10次方）
1MB = 1024KB（2的10次方）
1GB = 1024MB（2的10次方）
这里大家不要迷惑，为什么是2的10次方，而不是3的10次方，也不是2的15次方。
"就是这么规定的，爱玩不玩！"

具体怎么定的这个规则，肯定有原因，肯定也能查到历史。具体各位在自行查看中外文档吧，查到了也请告知。

### 计算机基础与位的进化史

这里说计算机/手机的两个层面，一个是内存条，一个是CPU。

#### 内存条
实实在在的东西，有4GB、8GB、16GB等大小，长条形的带黑边的玩意，实体店网店都能买到，笔记本的小一些，台式机的大一些，有各种型号。手机的内存条是出厂固定在里面的，不好弄。
插到计算机的主板上面就能使用了。如果电脑开机的时候出现`滴滴滴`的声音，就把内存条拔出来檫檫，有很大概率能好。
**内存条硬性决定了我们可用的最大内存。**

#### CPU
**CPU软件决定了我们可用的最大内存。(其中寄存器为根本原因)**
CPU决定我们的操作系统是`32位`还是`64位`（甚至8位，16位等）。
这里的`32位`和`64位`，指的是`内存地址`的`位`大小。

内存条是硬件存储设备。它随随便便就能支持8GB的数据存储。各位知道8GB是多大吗？8GB = 8G \* 1024M \* 1024K \* 1024Byte，也就是`8589934592`Byte(字节)。
再恐怖点，1Byte=8Bit，Bit才是最小存储单元，所以真实存储是：`8589934592 * 8`即`68719476736`Bit（比特）。

逆过来分析：
这么大的比特数据，在内存条是按照8Bit一组排列的。
每8Bit形成一个小房间。所以8GB的内存条里面，有`68719476736 / 8`个房间。
计算机操作系统可以通过`定向寻址`的方案，直接找到每个房间。形象来说，就是每个房间都有一个`内存地址`,系统通过`内存地址`就可以一瞬间biu～一下就到那个房间，房间里面有8个小人(8Bit)。

`内存地址`是关键，他是什么东西？
就是刚才我们说到的`32位`和`64位`CPU。如果CPU是32位，那么`内存地址`最小为：`00000000 00000000 00000000 00000000`，最大为：`11111111 11111111 11111111 11111111`。64位就`00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000`和`11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111`。
对于32位CPU来说，这最小和最大之间，有多少个呢？因为每个Bit有`0`和`1`两个选择，所以总共有2的32次方个。每一个都一一对应内存条里面的一个房间，所以最多可以对应`2*2*2*2(32个2相乘)=4294967296`个房间。
每个房间是8Bit即1Byte(字节)，也就是总房间大小为:`4294967296Byte`，也就是`4294967296Byte/1024K/1024M/1024G = 4GB`。
**真相开始大白了，对于32位CPU的操作系统，最大的内存地址也就是：`11111111 11111111 11111111 11111111`。也就是最多只能找到`2*2*2*2(32个2相乘)=4294967296`个房间。也就是最大内存查找范围只有`4294967296Byte/1024K/1024M/1024G = 4GB`。**

原理分析完了，各位就知道一个现象了：
当年win7系统，明明买了8G的内存条，到`我到电脑`里面一看，只有4G不到。其余到4G不见了。
其实不是不见了，它还在那里，只是操作系统因为CPU到32位限制，读取不了更多到内存空间了。

(为什么32位的CPU，可使用的位数是32位？根本在于寄存器。所有的内存中的数据，全部都要通过读取到寄存器中才能参与运算和控制。32位的CPU，寄存器只有32个针脚。64位CPU的寄存器有64个针脚。)

#### 初步总结
32位的CPU操作系统，只能读取4G的内存空间，内存条有更多空间也读取不了了。本质原因在于`内存地址`，就是每个存储字节(房间)的`内存地址`(房间号)。
因为`内存地址`只有32位，`11111111 11111111 11111111 11111111`是`内存地址`的最大值，也就是最大门牌号。
如果我们把最大门牌号变大，那操作系统肯定能够读取到更多到房间。
`64位`CPU到最大`内存地址`是：`11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111`，即`18446744073709551616`，这代表有`18446744073709551616`个房间，也就是`18446744073709551616Byte/1024K/1024M/1024G = 17179869184GB`。恐怖不恐怖？但是目前综合技术限制，我们更多使用的是8G内存、16G内存和32G内存，更大到商用的，我没听过了。
所以win7系统，明明放了8G内存条，只能使用4G的解决方案就是：重装系统，装64位的。

### 指针

万物皆为C。即C语言。
后面孩子孙子辈的语言，尽管百花齐放，终究逃离不了指针。这是计算机发展史上的根基。

指针是什么？我理解的指针，就是存储一段数据，这个数据是什么？是`内存地址`。

```
int main(int argc, char *argv[]) {
    int a = 5;
    int *p = &a;
}
```

上面代码中，如何通过p找到5？

5是int类型的数据，所以在32位的内存条中这样存储：`00000000 00000000 00000000 00000101`。它占据4个房间。
a是什么？a是给我们程序员看的。代码编译后，a代表的就是符号，就是5的`内存地址`，所以a就是连续的4个房间的首个内存地址，第一个房间的`内存地址`是：`00000000 00000000 11111111 11111111`(我假设的)。后面三个房间分别二进制+1。通过第一个房间，就可以连续的找到`5`这个存储数据。
p呢，指向a的指针，所以系统在内存里面存储了`00000000 00000000 11111111 11111111`这个二进制数据，也就是把a的`内存地址`给存了下来。同时这个二进制数据也有自己的连续房间号内存地址：`00000000 11111111 11111111 11111111`(我假设的）。这个地址，就是p啦。
p如何找到5？就是p通过存储的a的内存地址，找到了`5`的第一个房间号，都找到房间号了，肯定也就找到5这个存储数据了。
那为什么p刚好找到4个房间，而不是找到6个或者10个房间呢？int *p，这个就是关键，指针也是有数据类型的，p指针是int类型，大小也只有4字节。

### 指针的指针

```
int main(int argc, char *argv[]) {
    int a = 5;
    int *p = &a;
    int **pp = &p;
}
```

各位看，这里又创建了指向p指针的指针。啥意思？就还是指针。只不过这个指针，指向的不是5这个数据，还是另一个指针。那`int ***ppp = &pp`呢？还是一样的，还是指针，这个指针指向pp的内存地址。

所以这个时候，系统在内存里面存储了`00000000 11111111 11111111 11111111`这个二进制数据，也就是把p的`内存地址`给存了下来。同时这个二进制数据也有自己的连续房间号内存地址：`00001111 11111111 11111111 11111111`(我假设的）。这个地址，就是pp啦。

指针的指针的指针的指针，也还是一样的逻辑。`int **********pppppppppp = &ppppppppp`。

### 内存分配

各位看到了，内存分配的本质，就是`内存地址`的存储和调用。
我们的代码，在经过`预编译、编译、汇编、链接、挂载`一系列操作后，才能够从代码变成寄存器里面的二进制进而运行起来。
而我们运行的二进制文件，是一个分区清晰的二进制。我们的变量的定义，如果没有在预编译和编译环节被忽略外（编译环节会优化代码），都会整齐的通过一个方式放置于二进制文件的一个分区中（细了考量很复杂，详见《程序员的自我修养》）。
每一个变量，在程序编译后，就不客观存在了，使用的是这个变量所对应的`内存地址`。我们通过`内存地址`找到对应的数据，或者通过`内存地址`找到上一个`内存地址`，并最终找到对应的数据。
总内存条很大，所以里面分了几个大区。如堆栈等，还有高低位的限制。总体来说，内存是按照一定的顺序进行存储的。
我们使用的那些字面量啊或者对象啊啥的，就是一块存储区域。操作系统（栈）或者我们自己（堆）在内存区里面创建了这个数据并存储了下来。因为数据存储在房间里，所以每个数据都有一串连续的房间号（内存地址）。
在指针的逻辑里面，我们赋值等操作的时候，就是把这个内存地址，不断的放在另一个内存区域里面进行记录，然后读取的时候一环一环的就读取到了最终存储房间。

### 内存分区

内存分区有多种，如堆、栈、静态区、全局区、代码区等。上面的理解了，这些都只是外部包装，虽然他们本身很复杂，但是理解起来会简单的多了。因为我也只是理解，就不夸夸其谈了。自行Google。
特别推荐《程序员的自我修养》这本书，道尽了代码是如何运行起来的。

___

C绝对是计算机语言的开荒基石。
熟练C的程序员，大脑里就有一片星辰大海。