---
title: iOS内存原理
date: 2019-01-06 11:30:48
categories:
- 技术
tags:
- iOS
keywords: 内存管理、内存释放、ARC、ARC内存原理
---

iOS 的内存管理，绝对是很多很多 iOSer 人的误区。
因为最近几年的 iOS 开发人员，都没有经历过 MRC 年代了。
MRC 年代的内存总是不好管理，所以 ARC 帮我们做了很多事情。ARC 做了很多事情让内存管理更加精准优秀外，却使得 iOS 开发人员不知道内存是怎么管理的了。
真正的内存管理，一定需要回到 MRC 下面去理解，根本思想是：**谁创建、谁释放、谁引用、谁管理**。
**内存释放的唯一途径是：引用计数=0**
自动释放池仅仅做了“谁创建谁释放”里面的一部分。
**ARC 帮我们做了“谁创建、谁释放、谁引用、谁管理”四个部分。**
**ARC 帮我们写了很多管理内存的代码，包括 autolease、retain、release 等。如果不理解 MRC 下面他们的含义，是不可能理解 iOS 内存管理的。**
**网络上面大多介绍的 autolease、autoleasepool、autoleasepoolpage，只是自动释放池部分，只是 iOS 内存管理的一个面。**

在 ARC 下，我们虽然不需要写 retain 和 release，不代表他们不存在了。只是编译器帮我们自动添加了，并且在合适的时间添加的。只有编译器也不行，在运行时也会进行内存的控制。在编译和运行时两方的协调控制下，才做到了引用计数及时=0，也只有计数=0，内存才正确释放。

ARC 内存不是绝对安全释放的，还牵涉到内存区，如果字符串定义到了堆区，释放是及时的，定义到了栈区和常量区，就不那么及时了（虽然引用计数=0，代码也不能在调用，但是真实内存还在）。
而且很可能还会因为代码原因导致引用计数永远不可能为 0，常见的就是循环引用，如 Block 的双向强引用，NSTimer 的双向强引用等等，这里都需要特别的破环。解决双向引用的问题，核心在于破环，只要有一个缺口，内存不可能不释放。

深入理解**自己生成的对象，自己持有、非自己生成的对象，自己也能持有、不再需要自己持有的对象需要释放、非自己持有的对象无法释放**，就能深入理解 iOS 的内存管理。
强烈推荐《Objective-C高级编程》，网上所有说明几乎均处于此。与其不断的翻阅二手说明书，弄的自己眼花缭乱，不如拿着原版，仔细啃食。
